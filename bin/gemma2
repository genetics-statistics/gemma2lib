#!/usr/bin/env python3
#
# This is the main gemma2 starting point. It is parses command line
# arguments and hands them off to other modules.

import click # command line parsing
import logging
import pprint
import sys

from click import echo
from itertools import chain
from os.path import dirname
from subprocess import run,CompletedProcess
from toolz.functoolz import pipe

BASEDIR=str.strip(pipe(__file__,dirname,dirname)) or "."
VERSION=open(BASEDIR+"/VERSION").read()

print("GEMMA2",VERSION.strip(),"Genome-wide efficient 'exact' mixed-model analysis by Pjotr Prins, Xiang Zhou and others")

sys.path.append(BASEDIR)
import gemma2 # you may need to add source to PYTHONPATH
from gemma2.format.rqtl2 import load_control, load_geno
from gemma2.format.plink import convert_plink
from gemma2.format.bimbam import write_bimbam
from gemma2.utility.options import set_options, get_options_ns

second = ["gwa"]
split_on = ["%", "'=>'"]
dump_stacktrace = False

def gemma1_pass(bin,args):
    """At this stage a simple pass-through"""
    args1 = list(args)
    # locate gemma
    args1.insert(0,bin)
    cmd = " ".join(args1)
    logging.warning("Gemma1 -- should read the docs -- compatibility mode calling:\n"+cmd)
    # print(args1)
    run(args1)

# -------------------------------------------------------------------------------
# Grouping multi commands, see https://click.palletsprojects.com/en/7.x/commands/
# @click.group(invoke_without_command=True)
@click.group()
@click.option('--outdir', type=str, default=".", show_default=True,
              help="Specify output directory path")
@click.option('--validate/--no-validate', default=False, show_default=True,
              help="Validate input and output")
@click.option('--debug', type=click.Choice(['RAM','STACK','ALL'],
                                           case_sensitive=False),
                                           default=None,
                                           help="Debug options")
@click.option('-v','--verbose', type=int, default=1, show_default=True, count=True,
              help="Verbosity levels 0-9")
@click.option('--log',type=click.Choice(['DEBUG', 'INFO', 'WARNING', 'ERROR'],
                                        case_sensitive=False),
                                        default = 'WARNING',
                                        show_default=True)
@click.option('--low-mem',is_flag=True,help="Optimize for low(er) RAM")
# @click.argument('args', nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def gemma2(ctx,outdir,debug,verbose,validate,log,low_mem):
    # if not ctx.invoked_subcommand:
    #   echo("Passing on to gemma1!!")
    #   gemma1_pass(list(args))
    ctx.ensure_object(dict)
    opts = {}

    opts['debug'] = debug
    global dump_stacktrace
    dump_stacktrace = debug == 'STACK' or debug == 'ALL'
    opts['verbose'] = verbose
    opts['validate'] = validate
    if verbose > 1 and log == 'WARNING':
        log = 'INFO' # bump log level so we don't have to do that every time
    opts['log'] = log
    opts['outdir'] = outdir
    opts['low_mem'] = low_mem
    if log:
        logger = { 'DEBUG': logging.DEBUG,
                   'INFO': logging.INFO,
                   'WARNING': logging.WARNING,
                   'ERROR': logging.ERROR
        }
        logging.basicConfig(level=logger[log])

    set_options(opts)
    ctx.obj['OPTIONS'] = get_options_ns()
    if verbose:
        echo(opts)

# -------------------------------------------------------------------------------
# The gemma1 command does a simple pass through without command line
# checking! This is for quick testing only as it finds the gemma
# binary
@gemma2.command(context_settings=dict(ignore_unknown_options=True),
                help="Raw GEMMAv1 pass through mode")
# @click.argument('bin', envvar='GEMMA1_BIN', type=click.File('r'), default="gemma")
@click.option('--bin', type=str, default="gemma", envvar='GEMMA1_BIN', show_default=True, help="Path or binary name pointing to GEMMAv1 (alternatively set GEMMA1_BIN)")
@click.argument('args', nargs=-1, type=click.UNPROCESSED)

def gemma1(bin,args):
    cmdline = list(args)
    gemma1_pass(bin,args)

# -------------------------------------------------------------------------------
@gemma2.command(help="Convert from PLINK or BIMBAM to GEMMA2/Rqtl2 format")
# @click.argument
#  -bfile    [prefix]        specify input PLINK binary ped file prefix.
#           requires: *.fam, *.bim and *.bed files
@click.option('--plink', type=str,
              help="Convert path (prefix to .fam, .bim and .bed) to GEMMA2 format")

@click.option('--compression-level', type=int, default=7, show_default=True, help="Compression level for gz output")
@click.pass_context

def read(ctx,plink,compression_level):
    if plink:
        echo("Converting from PLINK to GEMMA2/Rqtl2 format...")
        convert_plink(plink,compression_level)

# -------------------------------------------------------------------------------
@gemma2.command(help="Convert from GEMMA2/Rqtl2 format to BIMBAM")
# @click.argument
#  -bfile    [prefix]        specify input PLINK binary ped file prefix.
#           requires: *.fam, *.bim and *.bed files
@click.option('--bimbam',is_flag=True,required=True,
              help="Convert GEMMA2 format to BIMBAM (requires control file)")
@click.option('--control','-c',type=click.Path(exists=True, readable=True),
              required=True,
              help="GEMMA2 control file (JSON)")
@click.option('--compression-level', type=int, default=7, show_default=True, help="Compression level for gz output")
@click.pass_context

def write(ctx,compression_level,bimbam,control):
    # if not control:
    #     raise Exception("You need a control file for conversion to BIMBAM")
    echo("Converting from GEMMA2/Rqtl2 format to BIMBAM...")
    write_bimbam(control,compression_level)

# -------------------------------------------------------------------------------
@gemma2.command(help="Filtering commands")
@click.pass_context

def filter(ctx):
    echo('- Filter data')

# -------------------------------------------------------------------------------
@gemma2.command(help="Validation commands")
@click.pass_context

def validate(ctx):
    echo('- Validate data')

# -------------------------------------------------------------------------------
@gemma2.command(help="Compute kinship/genetic relationship matrix (GRM)")
@click.option('--control','-c',type=click.Path(exists=True, readable=True),required=True,help="GEMMA2 control file (JSON)")
@click.pass_context

def grm(ctx,control):
    opts = get_options_ns()
    if opts.debug:
        echo('- Kinship/Genetic Relationship Matrix (GRM) command')
    c = load_control(control)
    G = load_geno(c)
    # K = compute_kinship(G)

@gemma2.command(help="Compute genome-wide association (GWA)")
@click.option('--iterations', default=1_000)
@click.pass_context

def lmm(ctx,iterations):
    echo('** Genome-wide Association (GWA)')

gemma2.add_command(read)
gemma2.add_command(write)
gemma2.add_command(gemma1)
gemma2.add_command(filter)
gemma2.add_command(grm)
gemma2.add_command(lmm)

import traceback

try:
    gemma2()
except Exception:
    # exc_type, exc_value, exc_traceback = sys.exc_info()
    if dump_stacktrace:
        traceback.print_exc()
    else:
        traceback.print_exc(limit=-1)
        echo("Use switch --debug STACK to get a full stack trace")
